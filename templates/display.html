<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>moblin-smart-translation — 出力</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 0;
        background: transparent;
        overflow: hidden;
      }
      #root {
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: flex-end; /* stick text near bottom */
        justify-content: center;
        padding-bottom: 4vh;
      }
      #viewport {
        max-width: 96vw;
        overflow: hidden; /* hide lines above the visible window */
        display: flex;
        align-items: flex-end; /* keep latest lines at the bottom of the window */
      }
      #text-box {
        width: 100%;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <div id="root">
      <div id="viewport">
        <div id="text-box"></div>
      </div>
    </div>
    <script>
      const STORAGE_KEY = "mst_text_settings_v1";
      const box = document.getElementById("text-box");
      const viewport = document.getElementById("viewport");

      function loadSettings() {
        try {
          const raw = window.localStorage.getItem(STORAGE_KEY);
          if (!raw) return null;
          return JSON.parse(raw);
        } catch {
          return null;
        }
      }

      function applySettings(text) {
        const s = loadSettings() || {};

        const fontSize = Number(s.fontSize) || 42;
        const lineHeight = Number(s.lineHeight) || 1.2;
        const align = s.align || "center";
        // 最大行数は 3 行で固定。
        const maxLines = 3;
        const color = s.color || "#ffffff";
        const padding = Number(s.padding) || 16;

        let family;
        switch (s.fontFamily) {
          case "mono":
            family = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
            break;
          case "serif":
            family = '"Georgia", "Times New Roman", serif';
            break;
          case "sans":
            family = 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
            break;
          default:
            family = 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        }

        box.style.fontFamily = family;
        box.style.fontSize = fontSize + "px";
        box.style.lineHeight = lineHeight;
        box.style.textAlign = align;
        box.style.color = color;
        box.style.padding = padding + "px";

        // Viewport height: roughly 3 lines of text + vertical padding.
        // This ensures that visually only about 3 lines are visible; any
        // older content above is clipped by the viewport.
        const linePx = fontSize * lineHeight;
        const viewportHeight = linePx * maxLines + padding * 2;
        viewport.style.height = `${viewportHeight}px`;

        // Convert the raw transcript into short visual slots so that
        // we can hard-cap the visible rows to maxLines even when a
        // single logical line is very long. Then iteratively choose
        // tail slots until the rendered height fits in the viewport.
        const raw = text || "";
        const logicalLines = raw.split(/\r?\n/).filter((l) => l.trim() !== "");
        const slots = [];
        const charsPerSlot = 48; // approx width for large subtitles
        for (const ln of logicalLines) {
          let rest = ln.trim();
          while (rest.length > 0) {
            slots.push(rest.slice(0, charsPerSlot));
            rest = rest.slice(charsPerSlot);
          }
        }

        let selected = [];
        for (let i = slots.length - 1; i >= 0; i -= 1) {
          selected.unshift(slots[i]);
          box.textContent = selected.join("\n");
          const rect = box.getBoundingClientRect();
          if (rect.height > viewportHeight || selected.length >= maxLines) {
            selected.shift();
            break;
          }
        }
        box.textContent = selected.join("\n");

        const bg = s.background || "transparent";
        if (bg === "transparent") {
          box.style.background = "transparent";
          box.style.backdropFilter = "none";
        } else if (bg === "dark") {
          box.style.background = "rgba(15,23,42,0.72)";
          box.style.backdropFilter = "blur(18px)";
        } else {
          box.style.background = "#020617";
          box.style.backdropFilter = "none";
        }

        if (s.shadow === "none") {
          box.style.textShadow = "none";
        } else {
          box.style.textShadow = "0 0 8px rgba(0,0,0,0.9)";
        }
      }

      async function pollTranscript() {
        try {
          const res = await fetch("/transcript", { cache: "no-store" });
          if (!res.ok) throw new Error("HTTP " + res.status);
          const data = await res.json();
          applySettings(data.text || "");
        } catch (err) {
          console.error(err);
        } finally {
          setTimeout(pollTranscript, 1000);
        }
      }

      applySettings("");
      pollTranscript();
    </script>
  </body>
</html>
